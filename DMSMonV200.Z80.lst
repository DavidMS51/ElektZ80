0000                             ;DMSMON-Z80 v2.00 for Z80
0000                             ;Copyright 2021 David Saul  https://meanderingpi.com/
0000                             ; 
0000                             ;Built on fork of GWMON-80 v0.1.4 for 8080/8085/Z80 and Compatibles
0000                             ;Copyright (c) 2019 The Glitch Works
0000                             ;http://www.glitchwrks.com
0000                             ; 
0000                             ;Coded specifically for Z80 based computers
0000                             ;with additional / modified funtionality as described below
0000                             ; 
0000                             ; Intering X during entry abouts dump command
0000                             ; In and Out re-written for Z80 - 8080 dynamic code delated
0000                             ; x also aborts ( not just X)
0000                             ; Welcome message personalised to DMSMon
0000                             ; Help command added
0000                             ; 
0000                             ; 
0000                             ; 
0000                STACK:    EQU   $0fff   ; top of CPU Board RAM
0000                RAMST:    EQU   $0800   ; start of CPU board RAM
0000                          .ORG   0000H   
0000                             ; 
0000                             ;Initialization and sign-on message
0000   C3 6A 02     LOG:      JP   SETUP   
0040                          .ORG   $0040   ; leave restart addresses available
0040                             ; 
0040                             ;Check for first boot - if true skip trial command setup
0040                             ; 
0040   21 00 08     SE1:      LD   HL,RAMST   ; Test the first 3 RAM locations, if they are all zero
0043   3E 00                  LD   A,00   ; assume this is not a power up start so don't
0045   86                     ADD   A,(HL)   ; setup the default test command code
0046   23                     INC   HL   
0047   86                     ADD   A,(HL)   
0048   23                     INC   HL   
0049   86                     ADD   A,(HL)   
004A   28 06                  JR   Z,SE2   
004C                             ; 
004C                             ;Assume this is cold start to write default ret test code to RAM
004C   21 00 08               LD   HL,RAMST   ; point to test command code start
004F   3E C7                  LD   A,$C7   ; RST0 code
0051   77                     LD   (HL),A   ; insert into RAMST
0052                             ; 
0052                             ; 
0052   21 BB 04     SE2:      LD   HL,LOGMSG   
0055   CD E4 01               CALL   STROUT   
0058   21 89 05               LD   HL,VERSION   
005B   CD E4 01               CALL   STROUT   
005E   21 70 05               LD   HL,FLINE   
0061   CD E4 01               CALL   STROUT   
0064   21 F3 02               LD   HL,MSG   
0067   CD E4 01               CALL   STROUT   
006A                             ; 
006A                             ;Main command loop
006A   21 7C 04     CMDLP:    LD   HL,PROMPT   
006D   CD E4 01               CALL   STROUT   
0070   21 6A 00               LD   HL,CMDLP   ; Get CMDLP address in HL
0073   E5                     PUSH   HL   ; Push HL, prime stack for RET to CMDLP
0074   CD C8 02               CALL   CIN   
0077   E6 5F                  AND   $5F   
0079   FE 44                  CP   "D"   
007B   CA 12 01               JP   Z,MEMDMP   
007E   FE 45                  CP   "E"   
0080   CA D5 00               JP   Z,EDMEM   
0083   FE 47                  CP   "G"   
0085   CA 09 01               JP   Z,GO   
0088   FE 4F                  CP   "O"   
008A   28 26                  JR   Z,OUTPUT   
008C   FE 49                  CP   "I"   
008E   28 33                  JR   Z,INPUT   
0090   FE 4C                  CP   "L"   
0092   CA FE 01               JP   Z,LOAD   
0095   FE 54                  CP   "T"   
0097   CA A8 00               JP   Z,TEST   
009A   FE 48                  CP   "H"   
009C   CA AB 00               JP   Z,HELP   
009F   FE 0D                  CP   $0D   ; just loop if CR - ie don't disp an error
00A1   C8                     RET   Z   
00A2   21 8A 04               LD   HL,ERR   
00A5   C3 EE 01               JP   ERROUT   
00A8                             ; 
00A8                             ;Execute monitor development code
00A8                             ;the T command will jump to the RAM base and execute the code at that point
00A8                             ;a RET brings it back to the menu, this allow monitor routines to be developmed without having to keep
00A8                             ;re-flashing to the EEPROM. You just lode the test code as a hex8 file at the RAMbase.
00A8                             ;default code is loaded on a cold start to give a default response
00A8                             ;test code must be preceeded with 3 NOPs to all the monitor to differenciate between code and warm starts
00A8                             ;test code should finish with a RET to get back to the core monitor
00A8                             ;A warm start will not overwrite the test code
00A8   C3 00 08     TEST:     JP   RAMST   
00AB                             ; 
00AB                             ; 
00AB                             ;display help info and program credits
00AB   21 16 03     HELP:     LD   HL,HELPT   
00AE   CD E4 01               CALL   STROUT   
00B1   C9                     RET      
00B2                             ; 
00B2                             ; 
00B2                             ;Get a port address, write byte out
00B2   CD DE 01     OUTPUT:   CALL   SPCOUT   
00B5   CD 98 01               CALL   GETHEX   
00B8   47                     LD   B,A   
00B9   CD DE 01               CALL   SPCOUT   
00BC   CD 98 01               CALL   GETHEX   
00BF   CD D6 01               CALL   JMPOUT   
00C2   C9                     RET      
00C3                             ; 
00C3                             ;Input from port, print contents
00C3   CD DE 01     INPUT:    CALL   SPCOUT   
00C6   CD 98 01               CALL   GETHEX   
00C9   47                     LD   B,A   
00CA   CD DE 01               CALL   SPCOUT   
00CD   78                     LD   A,B   
00CE   CD DA 01               CALL   JMPIN   
00D1   CD 5C 01               CALL   HEXOUT   
00D4   C9                     RET      
00D5                             ; 
00D5                             ;Edit memory from a starting address until X is
00D5                             ;pressed. Display mem loc, contents, and results
00D5                             ;of write.
00D5   CD DE 01     EDMEM:    CALL   SPCOUT   
00D8   CD 85 01               CALL   ADRIN   
00DB   62                     LD   H,D   
00DC   6B                     LD   L,E   
00DD   CD F5 01     ED1:      CALL   CRLF   
00E0   CD 7C 01               CALL   ADROUT   
00E3   CD DE 01               CALL   SPCOUT   
00E6   3E 3A                  LD   A,":"   
00E8   CD CE 02               CALL   COUT   
00EB   CD DE 01               CALL   SPCOUT   
00EE   CD 57 01               CALL   DMPLOC   
00F1   CD DE 01               CALL   SPCOUT   
00F4   CD 98 01               CALL   GETHEX   
00F7   FE 0D                  CP   $0D   ; Check for CR if so move to next add and don't update
00F9   28 0B                  JR   Z,ED2   
00FB   77                     LD   (HL),A   
00FC   CD DE 01               CALL   SPCOUT   
00FF   CD 57 01               CALL   DMPLOC   
0102   23           ED3:      INC   HL   
0103   C3 DD 00               JP   ED1   
0106   00           ED2:      NOP      
0107   18 F9                  JR   ED3   
0109                             ; 
0109                             ;Get an address and jump to it
0109   CD DE 01     GO:       CALL   SPCOUT   
010C   CD 85 01               CALL   ADRIN   
010F   62                     LD   H,D   
0110   6B                     LD   L,E   
0111   E9                     JP   (HL)   
0112                             ; 
0112                             ;Dump memory between two address locations - AS CURRENTLY CODED THIS IS A MAX 8K BLOCK
0112   CD DE 01     MEMDMP:   CALL   SPCOUT   
0115   CD 85 01               CALL   ADRIN   
0118   62                     LD   H,D   ; Start in HL
0119   6B                     LD   L,E   
011A   0E 10                  LD   C,$10   
011C   CD DE 01               CALL   SPCOUT   
011F   CD 85 01               CALL   ADRIN   ; End in DE
0122   CD BE 02     MD1:      CALL   CINW   ; test for abort
0125   FE 58                  CP   "X"   
0127   C8                     RET   Z   
0128   FE 78                  CP   "x"   
012A   C8                     RET   Z   
012B   CD F5 01               CALL   CRLF   
012E   CD 3F 01               CALL   DMP16   
0131   7A                     LD   A,D   ; High byte of end address
0132   BC                     CP   H   ; Compare current high address
0133   F8                     RET   M   ; Done if current high > end high
0134   7B                     LD   A,E   ; Low byte of end address
0135   BD                     CP   L   ; Compare current low address
0136   38 02                  JR   C,MD2   ; Current low > end low, check for rollover
0138   18 E8                  JR   MD1   ; Continue dumping memory
013A   7A           MD2:      LD   A,D   ; High byte of end address
013B   BC                     CP   H   ; Are high bytes the same?
013C   20 E4                  JR   NZ,MD1   ; Keep going if upper bytes aren't the same
013E   C9                     RET      ; Done if they are
013F                             ; 
013F                             ; 
013F                             ;DMP16 -- Dump 16 consecutive memory locations
013F                             ; 
013F                             ;pre: HL pair contains starting memory address
013F                             ;post: memory from HL to HL + 16 printed
013F                             ;post: HL incremented to HL + 16
013F                             ; 
013F   CD 7C 01     DMP16:    CALL   ADROUT   
0142   CD DE 01               CALL   SPCOUT   
0145   3E 3A                  LD   A,":"   
0147   CD CE 02               CALL   COUT   
014A   0E 10                  LD   C,$10   
014C   CD DE 01     DM1:      CALL   SPCOUT   
014F   CD 57 01               CALL   DMPLOC   
0152   23                     INC   HL   
0153   0D                     DEC   C   
0154   C8                     RET   Z   
0155   18 F5                  JR   DM1   
0157                             ; 
0157                             ; 
0157                             ;DMPLOC -- Print a byte at HL to console
0157                             ; 
0157                             ;pre: HL pair contains address of byte
0157                             ;post: byte at HL printed to console
0157                             ; 
0157   7E           DMPLOC:   LD   A,(HL)   
0158   CD 5C 01               CALL   HEXOUT   
015B   C9                     RET      
015C                             ; 
015C                             ; 
015C                             ;HEXOUT -- Output byte to console as hex
015C                             ; 
015C                             ;pre: A register contains byte to be output
015C                             ;post: byte is output to console as hex
015C                             ; 
015C   C5           HEXOUT:   PUSH   BC   
015D   47                     LD   B,A   
015E   0F                     RRCA      
015F   0F                     RRCA      
0160   0F                     RRCA      
0161   0F                     RRCA      
0162   E6 0F                  AND   0Fh   
0164   CD 75 01               CALL   HEXASC   
0167   CD CE 02               CALL   COUT   
016A   78                     LD   A,B   
016B   E6 0F                  AND   0Fh   
016D   CD 75 01               CALL   HEXASC   
0170   CD CE 02               CALL   COUT   
0173   C1                     POP   BC   
0174   C9                     RET      
0175                             ; 
0175                             ; 
0175                             ;HEXASC -- Convert nybble to ASCII char
0175                             ; 
0175                             ;pre: A register contains nybble
0175                             ;post: A register contains ASCII char
0175                             ; 
0175   C6 90        HEXASC:   ADD   A,$90   
0177   27                     DAA      
0178   CE 40                  ADC   A,$40   
017A   27                     DAA      
017B   C9                     RET      
017C                             ; 
017C                             ; 
017C                             ;ADROUT -- Print an address to the console
017C                             ; 
017C                             ;pre: HL pair contains address to print
017C                             ;post: HL printed to console as hex
017C                             ; 
017C   7C           ADROUT:   LD   A,H   
017D   CD 5C 01               CALL   HEXOUT   
0180   7D                     LD   A,L   
0181   CD 5C 01               CALL   HEXOUT   
0184   C9                     RET      
0185                             ; 
0185                             ; 
0185                             ;ADRIN -- Get an address word from console
0185                             ; 
0185                             ;pre: none
0185                             ;post: DE contains address from console
0185                             ; 
0185   CD 98 01     ADRIN:    CALL   GETHEX   
0188   FE 0D                  CP   $0D   ; test for CR if so about
018A   CA 61 02               JP   Z,WARMB   
018D   57                     LD   D,A   
018E   CD 98 01               CALL   GETHEX   
0191   FE 0D                  CP   $0D   ; test for CR if so about
0193   CA 61 02               JP   Z,WARMB   
0196   5F                     LD   E,A   
0197   C9                     RET      
0198                             ; 
0198                             ; 
0198                             ;GETHEX -- Get byte from console as hex
0198                             ; 
0198                             ;pre: none
0198                             ;post: A register contains byte from hex input
0198                             ; or if CR returns CR code - 0DH
0198                             ; 
0198   D5           GETHEX:   PUSH   DE   
0199   CD 8E 02     ERC:      CALL   CINHX   
019C   FE 0D                  CP   $0D   ; check for CR if true just return with it
019E   28 13                  JR   Z,GE1   ; i.e. skip hex conversion
01A0   CD CC 01               CALL   ASCHEX   
01A3   07                     RLCA      
01A4   07                     RLCA      
01A5   07                     RLCA      
01A6   07                     RLCA      
01A7   57                     LD   D,A   
01A8   CD 8E 02               CALL   CINHX   
01AB   FE 0D                  CP   $0D   ; should never get here but just in case check for CR if true just return with it
01AD   28 04                  JR   Z,GE1   ; i.e. skip hex conversion
01AF   CD CC 01               CALL   ASCHEX   
01B2   B2                     OR   D   
01B3   D1           GE1:      POP   DE   
01B4   C9                     RET      
01B5                             ; 
01B5                             ; 
01B5                             ;GETHEX8 -- Get byte from console as hex, USED foe HEX8 LOADS ONLY
01B5                             ; 
01B5                             ;pre: none
01B5                             ;post: A register contains byte from hex input
01B5                             ; 
01B5                             ; 
01B5   D5           GETHEX8:   PUSH   DE   
01B6   CD 85 02               CALL   CINNE   
01B9   CD CC 01               CALL   ASCHEX   
01BC   07                     RLCA      
01BD   07                     RLCA      
01BE   07                     RLCA      
01BF   07                     RLCA      
01C0   57                     LD   D,A   
01C1   CD 85 02               CALL   CINNE   
01C4   CD CC 01               CALL   ASCHEX   
01C7   B2                     OR   D   
01C8   D1                     POP   DE   
01C9   D3 05                  OUT   (5),A   
01CB   C9                     RET      
01CC                             ; 
01CC                             ; 
01CC                             ;ASCHEX -- Convert ASCII coded hex to nybble
01CC                             ; 
01CC                             ;pre: A register contains ASCII coded nybble
01CC                             ;post: A register contains nybble
01CC                             ; 
01CC   D6 30        ASCHEX:   SUB   30h   
01CE   FE 0A                  CP   $0A   
01D0   F8                     RET   M   
01D1   E6 5F                  AND   $5F   
01D3   D6 07                  SUB   $07   
01D5   C9                     RET      
01D6                             ; 
01D6                             ; 
01D6                             ;JMPOUT -- Output to a dynamic port - this has be altered to use extended Z80 commands
01D6                             ; 
01D6                             ;pre: B register contains the port to output to
01D6                             ;pre: A register contains the byte to output
01D6                             ;post: byte is output
01D6                             ; 
01D6                JMPOUT:      
01D6                             ; 
01D6   48                     LD   C,B   
01D7   ED 79                  OUT   (C),A   
01D9   C9                     RET      
01DA                             ; 
01DA                             ; 
01DA                             ;JMPIN -- Input from a dynamic port - this has be altered to use extended Z80 commands
01DA                             ; 
01DA                             ;pre: A register contains the port to input from
01DA                             ;post: A register contains port value
01DA                             ; 
01DA                JMPIN:       
01DA   4F                     LD   C,A   
01DB   ED 78                  IN   A,(C)   
01DD   C9                     RET      
01DE                             ; 
01DE                             ; 
01DE                             ; 
01DE                             ;SPCOUT -- Print a space to the console
01DE                             ; 
01DE                             ;pre: none
01DE                             ;post: 0x20 printed to console
01DE                             ; 
01DE   3E 20        SPCOUT:   LD   A," "   
01E0   CD CE 02               CALL   COUT   
01E3   C9                     RET      
01E4                             ; 
01E4                             ; 
01E4                             ;STROUT -- Print a null-terminated string
01E4                             ; 
01E4                             ;pre: HL contains pointer to start of a null-
01E4                             ;     terminated string
01E4                             ;post: string at HL printed to console
01E4                             ; 
01E4   7E           STROUT:   LD   A,(HL)   
01E5   FE 00                  CP   00   
01E7   C8                     RET   Z   
01E8   CD CE 02               CALL   COUT   
01EB   23                     INC   HL   
01EC   18 F6                  JR   STROUT   
01EE                             ; 
01EE                             ; 
01EE                             ;ERROUT -- Print a null-terminated error string
01EE                             ; 
01EE                             ;pre: HL contains pointer to start of a null-
01EE                             ;     terminated string
01EE                             ;post: string at HL printed to console
01EE                             ;post: program execution returned to command loop
01EE                             ; 
01EE   CD F5 01     ERROUT:   CALL   CRLF   
01F1   CD E4 01               CALL   STROUT   
01F4   C9                     RET      
01F5                             ; 
01F5                             ; 
01F5                             ;CRLF -- Print a CR, LF
01F5                             ; 
01F5                             ;Preserves HL
01F5                             ; 
01F5                             ;pre: none
01F5                             ;post: CR, LF printed to console
01F5                             ; 
01F5   E5           CRLF:     PUSH   HL   
01F6   21 90 04               LD   HL,CRLFT   
01F9   CD E4 01               CALL   STROUT   
01FC   E1                     POP   HL   
01FD   C9                     RET      
01FE                             ; 
01FE                             ; 
01FE                             ;LOAD -- Load an Intel HEX file from console
01FE                             ; 
01FE                             ;post: Intel HEX file loaded, or error printed
01FE                             ; 
01FE                LOAD:        
01FE                             ;      LD      A,$10
01FE                             ;      OUT     (CTLPRT),A
01FE                             ;      LD      A, 02
01FE                             ;      CALL    DELV
01FE                             ;      LD      A,$15
01FE                             ;      OUT     (CTLPRT),A
01FE                             ;      LD      A, 02
01FE                             ;      CALL    DELV
01FE   CD 85 02     LOAD1:    CALL   CINNE   
0201   FE 3A                  CP   ":"   
0203   20 F9                  JR   NZ,LOAD1   ; Wait for start colon
0205   D3 05                  OUT   (5),A   
0207   CD B5 01               CALL   GETHEX8   ; Get record length
020A   47                     LD   B,A   ; Record length in B
020B   4F                     LD   C,A   ; Start checksumming in C
020C   CD B5 01               CALL   GETHEX8   ; Start address high byte
020F   67                     LD   H,A   ; Store in H
0210   81                     ADD   A,C   
0211   4F                     LD   C,A   ; Checksum
0212   CD B5 01               CALL   GETHEX8   ; Start address low byte
0215   6F                     LD   L,A   ; Store in L
0216   81                     ADD   A,C   
0217   4F                     LD   C,A   ; Checksum
0218   CD B5 01               CALL   GETHEX8   ; Get record type
021B   57                     LD   D,A   ; Store record type in D
021C   81                     ADD   A,C   
021D   4F                     LD   C,A   ; Checksum record type
021E   78                     LD   A,B   ; Check record length
021F   D3 04                  OUT   (4),A   
0221   A7                     AND   A   
0222   28 16                  JR   Z,LOAD4   ; Length == 0, done getting data
0224   CD B5 01     LOAD2:    CALL   GETHEX8   ; This is the main record processing loop
0227   77                     LD   (HL),A   ; Store char at HL
0228   81                     ADD   A,C   
0229   4F                     LD   C,A   ; Checksum
022A   78                     LD   A,B   
022B   F6 80                  OR   $80   
022D                             ;            OUT     (4), A
022D   23                     INC   HL   ; Move memory pointer up
022E   05                     DEC   B   
022F   20 F3                  JR   NZ,LOAD2   ; Not done with the line
0231   CD B5 01     LOAD3:    CALL   GETHEX8   ; Get checksum byte
0234   81                     ADD   A,C   
0235   20 13                  JR   NZ,CSUMER   ; Checksum bad, print error
0237   B2                     OR   D   
0238   28 C4                  JR   Z,LOAD   ; Record Type 00, keep going
023A   3E FF        LOAD4:    LD   A,$FF   
023C                             ;            OUT     (4), A
023C   CD 85 02               CALL   CINNE   ; Done getting data, silently eat chars
023F                             ;            OUT     (5), A
023F   FE 0A                  CP   $0A   ; Check for LF
0241   20 F7                  JR   NZ,LOAD4   
0243   21 A3 04               LD   HL,HEX8C   
0246   CD E4 01               CALL   STROUT   
0249   C9                     RET      ; Got LF, return to command loop
024A   21 81 04     CSUMER:   LD   HL,CSERR   ; Print checksum error to console
024D   C3 EE 01               JP   ERROUT   ; RET from ERROUT will return to command loop
0250                             ; 
0250                             ; 
0250                             ;DELV  simple delay loop 10mS x val in A
0250                             ; 
0250                             ;Preserves N/A everything but AF
0250                             ; 
0250                             ;pre:  A  x 10mS delay
0250                             ;post: Routine returns after delay registers are restored
0250                             ; 
0250                             ; 
0250   4F           DELV:     LD   C,A   
0251   C5                     PUSH   BC   
0252   D5                     PUSH   DE   
0253                DEL2:        
0253   11 9A 02               LD   DE,666   
0256   1B           DEL1:     DEC   DE   
0257   7B                     LD   A,E   
0258   B2                     OR   D   
0259   20 FB                  JR   NZ,Del1   
025B   0D                     DEC   C   
025C   20 F5                  JR   NZ,Del2   
025E   D1                     POP   DE   
025F   C1                     POP   BC   
0260   C9                     RET      
0261                             ; 
0261                             ; 
0261                             ; 
0261                             ;WARMB -- re-start monitor program without starting text
0261                             ; 
0261                             ;Preserves N/A
0261                             ; 
0261                             ;pre:  none - ignores state of stack etc
0261                             ;post: Stack back to the default starting point, sends 2 blank lines to the console
0261                             ; 
0261   31 FF 0F     WARMB:    LD   SP,STACK   
0264   CD F5 01               CALL   CRLF   
0267   C3 6A 00               JP   CMDLP   
026A                             ; 
026A                             ;========================================================================
026A                             ;Monitor I/O Module for Intel 8251 UART
026A                             ;Recoded for Z80 from Glitch Works 8080 monitor
026A                             ; 
026A                             ;Adjust CTLPRT and DATPRT for your specific hardware.
026A                             ;Stack Pointer initialized at 0x0FFF, adjust as needed.
026A                             ; 
026A                             ;After including this module, you still need to
026A                             ;set the ORG in the main monitor source.
026A                             ; 
026A                CTLPRT:   EQU   02H   
026A                DATPRT:   EQU   01H   
026A                             ; 
026A                             ; 
026A                             ;SETUP -- Prepare the system for running the
026A                             ;   monitor
026A                             ; 
026A                             ;pre: none
026A                             ;post: stack and console are initialized
026A                             ; 
026A   31 FF 0F     SETUP:    LD   SP,STACK   
026D   21 ED 02               LD   HL,INIUART   
0270   06 06                  LD   B,06H   ; length of ini string
0272   7E           INURT:    LD   A,(HL)   
0273   D3 02                  OUT   (CTLPRT),A   
0275   23                     INC   HL   
0276   05                     DEC   B   
0277   20 F9                  JR   NZ,INURT   
0279   CD DB 02               CALL   BEEP   
027C   3E 0F                  LD   A,$0F   ; set both PIO Channels mode 0 (output)
027E   D3 07                  OUT   (7),A   ; port B control reg
0280   D3 06                  OUT   (6),A   ; port A control reg
0282   C3 40 00               JP   SE1   
0285                             ; 
0285                             ; 
0285                             ; 
0285                             ; 
0285                             ;CINNE -- Get a char from the console, no echo, no validaion
0285                             ; 
0285                             ;pre: console device is initialized
0285                             ;post: received char is in A register
0285                             ; 
0285   DB 02        CINNE:    IN   A,(CTLPRT)   
0287   E6 02                  AND   02H   
0289   28 FA                  JR   Z,CINNE   
028B   DB 01                  IN   A,(DATPRT)   
028D   C9                     RET      
028E                             ; 
028E                             ; 
028E                             ;CINHX -- Get a char from the console, validate a good hex char, echo
028E                             ; 
028E                             ;pre: console device is initialized
028E                             ;post: received char is in A register
028E                             ; 
028E   DB 02        CINHX:    IN   A,(CTLPRT)   
0290   E6 02                  AND   02H   
0292   28 FA                  JR   Z,CINHX   
0294   DB 01                  IN   A,(DATPRT)   
0296   FE 58                  CP   "X"   ; First test for X or x if so abort
0298   CA 61 02               JP   Z,WARMB   
029B   FE 78                  CP   "x"   
029D   CA 61 02               JP   Z,WARMB   
02A0   FE 0D                  CP   $0D   ;test for carrage return
02A2   C8                     RET   Z   ; just return - do not try to echo
02A3   FE 30                  CP   $30   ; not an X so check it's valid ASCII
02A5   38 E7                  JR   C,CINHX   
02A7   FE 3A                  CP   $3A   
02A9   38 10                  JR   C,GOOD   
02AB   FE 41                  CP   $41   
02AD   38 DF                  JR   C,CINHX   ; cover upper and lower case a-f
02AF   FE 47                  CP   $47   
02B1   38 08                  JR   C,GOOD   
02B3   FE 61                  CP   $61   
02B5   38 D7                  JR   C,CINHX   
02B7   FE 67                  CP   $67   
02B9   30 D3                  JR   NC,CINHX   
02BB                             ; 
02BB   D3 01        GOOD:     OUT   (DATPRT),A   ; good entry so echo and return with it in A
02BD   C9                     RET      
02BE                             ; 
02BE                             ; 
02BE                             ;CINW -- check for a Char, no echo, non blocking
02BE                             ; 
02BE                             ;pre: console device is initialized
02BE                             ;post: received char is in A register, zero flag set and A put to Zero if no char in buffer
02BE                             ; 
02BE   DB 02        CINW:     IN   A,(CTLPRT)   ;check for available char
02C0   E6 02                  AND   02H   
02C2   3E 00                  LD   A,00   
02C4   C8                     RET   Z   
02C5   DB 01                  IN   A,(DATPRT)   
02C7   C9                     RET      
02C8                             ; 
02C8                             ; 
02C8                             ;CIN -- Get a char from the console and echo
02C8                             ;Use this where you need a non ASCII char otherwise use CINHX
02C8                             ; 
02C8                             ;pre: console device is initialized
02C8                             ;post: received char is in A register
02C8                             ;post: received char is echoed
02C8                             ; 
02C8   CD 85 02     CIN:      CALL   CINNE   
02CB   D3 01                  OUT   (DATPRT),A   
02CD   C9                     RET      
02CE                             ; 
02CE                             ; 
02CE                             ; 
02CE                             ; 
02CE                             ;COUT -- Output a character to the console
02CE                             ; 
02CE                             ;pre: A register contains char to be printed
02CE                             ;post: character is printed to the console
02CE                             ; 
02CE   C5           COUT:     PUSH   BC   
02CF   47                     LD   B,A   
02D0   DB 02        COUT1:    IN   A,(CTLPRT)   
02D2   E6 01                  AND   01H   
02D4   28 FA                  JR   Z,COUT1   
02D6   78                     LD   A,B   
02D7   D3 01                  OUT   (DATPRT),A   
02D9   C1                     POP   BC   
02DA   C9                     RET      
02DB                             ; 
02DB                             ; 
02DB                             ;BEEP  Sound beep length defined approx by A x 10ms
02DB                             ;Beep sount is enabled by setting the UART DTR line as such code sis specifc to 8251
02DB                             ; 
02DB                             ;Preserves N/A everything but AF
02DB                             ; 
02DB                             ;pre:  A  x 10mS beep length
02DB                             ;post: Routine returns after delay registers are restored
02DB                             ; 
02DB                             ; 
02DB   3A F2 02     BEEP:     LD   A,(UARTC)   ; load default UART control byte
02DE   F6 02                  OR   $02   ; Set DTR bit
02E0   D3 02                  OUT   (CTLPRT),A   
02E2   3E 32                  LD   A,50   ; should be about a 1/2 sec delay
02E4   CD 50 02               CALL   DELV   
02E7   3A F2 02               LD   A,(UARTC)   
02EA   D3 02                  OUT   (CTLPRT),A   ; restore default UART setting
02EC   C9                     RET      
02ED                             ; 
02ED                             ;Init string for the 8251, x16 clock, 8N1
02ED   00 00 00 40 4E INIUART:   DB   00H,00H,00H,40H,4EH   
02F2   15           UARTC:    DB   15H   ; UART Control reg config - transmit / recieve enabled, DTR high - buzzer off, RTS high - onboard LED on, Error reset
02F3                             ; 
02F3                             ;I/O Module description string
02F3   0D 0A 42 75 69 6C 74 20 77 69 74 68 20 49 6E 74 65 6C 20 38 32 35 31 20 49 2F 4F 20 6D 6F 64 75 6C 65 00 MSG:   DB   13,10,"Built with Intel 8251 I/O module",0   
0316                             ; 
0316                             ; 
0316                             ;Monitor Strings
0316                             ; 
0316   0D 0A 0A     HELPT:    DB   13,10,10   
0319   48 65 6C 70 0D 0A      DB   "Help",13,10   
031F   44 20 2D 20 44 69 73 70 6C 61 79 20 6D 65 6D 6F 72 79 20 78 78 78 78 20 74 6F 20 79 79 79 79 0D 0A DB   "D - Display memory xxxx to yyyy",13,10   
0340   45 20 2D 20 45 6E 74 65 72 20 44 61 74 61 20 61 74 20 79 79 79 79 20 65 6E 74 65 72 20 78 20 74 6F 20 61 62 6F 72 74 0D 0A DB   "E - Enter Data at yyyy enter x to abort",13,10   
0369   47 20 2D 20 52 75 6E 20 43 6F 64 65 20 61 74 20 78 78 78 78 0D 0A DB   "G - Run Code at xxxx",13,10   
037F   4C 20 2D 20 4C 6F 61 64 20 48 65 78 20 38 20 64 61 74 61 0D 0A DB   "L - Load Hex 8 data",13,10   
0394   4F 20 2D 20 4F 75 74 70 75 74 20 74 6F 20 50 6F 72 74 20 78 78 20 64 61 74 61 20 79 79 0D 0A DB   "O - Output to Port xx data yy",13,10   
03B3   49 20 2D 20 46 65 74 63 68 20 64 61 74 61 20 66 72 6F 6D 20 50 6F 72 74 20 78 78 20 0D 0A DB   "I - Fetch data from Port xx ",13,10   
03D1   54 20 2D 20 52 75 6E 20 74 65 73 74 20 63 6F 64 65 20 28 40 30 38 30 30 48 29 0D 0A DB   "T - Run test code (@0800H)",13,10   
03ED   48 20 2D 20 64 69 73 70 6C 61 79 20 74 68 69 73 20 6D 65 73 73 61 67 65 0D 0A 0A DB   "H - display this message",13,10,10   
0408   43 72 65 64 69 74 73 0D 0A DB   "Credits",13,10   
0411   44 4D 53 6D 6F 6E 20 32 2E 30 30 20 61 20 46 6F 72 6B 20 6F 66 20 47 57 4D 4F 4E 2D 38 30 20 30 2E 31 2E 34 20 72 65 63 6F 64 65 64 20 66 6F 72 20 5A 38 30 0D 0A DB   "DMSmon 2.00 a Fork of GWMON-80 0.1.4 recoded for Z80",13,10   
0447   43 6F 70 79 72 69 67 68 74 20 28 63 29 20 32 30 32 31 20 44 61 76 69 64 20 53 61 75 6C 2C 20 32 30 31 39 20 54 68 65 20 47 6C 69 74 63 68 20 57 6F 72 6B 73 00 DB   "Copyright (c) 2021 David Saul, 2019 The Glitch Works",0   
047C   0D 0A 0A 3E 00 PROMPT:   DB   13,10,10,">",0   
0481   43 48 45 43 4B 53 55 4D 20 CSERR:   DB   "CHECKSUM "   
048A   45 52 52 4F 52 00 ERR:   DB   "ERROR",0   
0490   0D 0A 00     CRLFT:    DB   13,10,0   
0493   6F 61 64 20 48 65 78 38 20 66 69 6C 65 0D 0A 00 HEX8L:   DB   "oad Hex8 file",13,10,0   
04A3   0D 0A 0A 48 65 78 38 20 6C 6F 61 64 20 63 6F 6D 70 6C 65 74 65 0D 0A 00 HEX8C:   DB   13,10,10,"Hex8 load complete",13,10,0   
04BB                             ; 
04BB                             ; 
04BB   0D 0A 0A     LOGMSG:   DB   13,10,10   
04BE   20 20 20               DB   "   "   ; the first chars miss align on powerup the extra hello
04C1   0D 0A 0A               DB   13,10,10   ; ensures the main boot message looks correct
04C4   58 58 58 58 20 20 58 20 20 20 58 20 20 58 58 58 0D 0A DB   "XXXX  X   X  XXX",13,10   
04D6   58 20 20 20 58 20 58 58 20 58 58 20 58 20 20 20 20 20 58 58 20 58 58 20 20 20 58 58 58 20 20 20 58 58 58 0D 0A DB   "X   X XX XX X     XX XX   XXX   XXX",13,10   
04FB   58 20 20 20 58 20 58 20 58 20 58 20 20 58 58 58 20 20 58 20 58 20 58 20 20 58 20 20 20 58 20 58 20 20 20 58 0D 0A DB   "X   X X X X  XXX  X X X  X   X X   X",13,10   
0521   58 20 20 20 58 20 58 20 20 20 58 20 20 20 20 20 58 20 58 20 58 20 58 20 20 58 20 20 20 58 20 58 20 20 20 58 0D 0A DB   "X   X X   X     X X X X  X   X X   X",13,10   
0547   58 58 58 58 20 20 58 20 20 20 58 20 20 58 58 58 20 20 58 20 20 20 58 20 20 20 58 58 58 20 20 58 20 20 20 58 0D 0A DB   "XXXX  X   X  XXX  X   X   XXX  X   X",13,10   
056D   0D 0A 00               DB   13,10,0   
0570                             ; 
0570                             ; 
0570   48 20 66 6F 72 20 68 65 6C 70 20 61 6E 64 20 63 72 65 64 69 74 73 0D 0A 00 FLINE:   DB   "H for help and credits",13,10,0   
0589                             ; 
0589   56 65 72 73 69 6F 6E 20 32 2E 30 30 0D 0A 00 VERSION:   DB   "Version 2.00",13,10,0   


STACK:              0FFF DEFINED AT LINE 19
                    > USED AT LINE 507
                    > USED AT LINE 534
RAMST:              0800 DEFINED AT LINE 20
                    > USED AT LINE 32
                    > USED AT LINE 42
                    > USED AT LINE 92
LOG:                0000 DEFINED AT LINE 24
SE1:                0040 DEFINED AT LINE 32
                    > USED AT LINE 547
SE2:                0052 DEFINED AT LINE 47
                    > USED AT LINE 39
CMDLP:              006A DEFINED AT LINE 57
                    > USED AT LINE 59
                    > USED AT LINE 509
TEST:               00A8 DEFINED AT LINE 92
                    > USED AT LINE 76
HELP:               00AB DEFINED AT LINE 96
                    > USED AT LINE 78
OUTPUT:             00B2 DEFINED AT LINE 102
                    > USED AT LINE 70
INPUT:              00C3 DEFINED AT LINE 111
                    > USED AT LINE 72
EDMEM:              00D5 DEFINED AT LINE 123
                    > USED AT LINE 66
ED1:                00DD DEFINED AT LINE 127
                    > USED AT LINE 142
ED3:                0102 DEFINED AT LINE 141
                    > USED AT LINE 144
ED2:                0106 DEFINED AT LINE 143
                    > USED AT LINE 137
GO:                 0109 DEFINED AT LINE 147
                    > USED AT LINE 68
MEMDMP:             0112 DEFINED AT LINE 154
                    > USED AT LINE 64
MD1:                0122 DEFINED AT LINE 161
                    > USED AT LINE 174
                    > USED AT LINE 177
MD2:                013A DEFINED AT LINE 175
                    > USED AT LINE 173
DMP16:              013F DEFINED AT LINE 187
                    > USED AT LINE 167
DM1:                014C DEFINED AT LINE 192
                    > USED AT LINE 197
DMPLOC:             0157 DEFINED AT LINE 205
                    > USED AT LINE 133
                    > USED AT LINE 140
                    > USED AT LINE 193
HEXOUT:             015C DEFINED AT LINE 215
                    > USED AT LINE 117
                    > USED AT LINE 206
                    > USED AT LINE 250
                    > USED AT LINE 252
HEXASC:             0175 DEFINED AT LINE 237
                    > USED AT LINE 222
                    > USED AT LINE 226
ADROUT:             017C DEFINED AT LINE 249
                    > USED AT LINE 128
                    > USED AT LINE 187
ADRIN:              0185 DEFINED AT LINE 261
                    > USED AT LINE 124
                    > USED AT LINE 148
                    > USED AT LINE 155
                    > USED AT LINE 160
GETHEX:             0198 DEFINED AT LINE 278
                    > USED AT LINE 103
                    > USED AT LINE 106
                    > USED AT LINE 112
                    > USED AT LINE 135
                    > USED AT LINE 261
                    > USED AT LINE 265
ERC:                0199 DEFINED AT LINE 279
GE1:                01B3 DEFINED AT LINE 293
                    > USED AT LINE 281
                    > USED AT LINE 290
GETHEX8:            01B5 DEFINED AT LINE 304
                    > USED AT LINE 428
                    > USED AT LINE 431
                    > USED AT LINE 435
                    > USED AT LINE 439
                    > USED AT LINE 447
                    > USED AT LINE 457
ASCHEX:             01CC DEFINED AT LINE 325
                    > USED AT LINE 282
                    > USED AT LINE 291
                    > USED AT LINE 306
                    > USED AT LINE 313
JMPOUT:             01D6 DEFINED AT LINE 339
                    > USED AT LINE 107
JMPIN:              01DA DEFINED AT LINE 351
                    > USED AT LINE 116
SPCOUT:             01DE DEFINED AT LINE 363
                    > USED AT LINE 102
                    > USED AT LINE 105
                    > USED AT LINE 111
                    > USED AT LINE 114
                    > USED AT LINE 123
                    > USED AT LINE 129
                    > USED AT LINE 132
                    > USED AT LINE 134
                    > USED AT LINE 139
                    > USED AT LINE 147
                    > USED AT LINE 154
                    > USED AT LINE 159
                    > USED AT LINE 188
                    > USED AT LINE 192
STROUT:             01E4 DEFINED AT LINE 374
                    > USED AT LINE 48
                    > USED AT LINE 50
                    > USED AT LINE 52
                    > USED AT LINE 54
                    > USED AT LINE 58
                    > USED AT LINE 97
                    > USED AT LINE 379
                    > USED AT LINE 390
                    > USED AT LINE 403
                    > USED AT LINE 469
ERROUT:             01EE DEFINED AT LINE 389
                    > USED AT LINE 82
                    > USED AT LINE 472
CRLF:               01F5 DEFINED AT LINE 401
                    > USED AT LINE 127
                    > USED AT LINE 166
                    > USED AT LINE 389
                    > USED AT LINE 508
LOAD:               01FE DEFINED AT LINE 412
                    > USED AT LINE 74
                    > USED AT LINE 461
LOAD1:              01FE DEFINED AT LINE 424
                    > USED AT LINE 426
LOAD2:              0224 DEFINED AT LINE 447
                    > USED AT LINE 456
LOAD3:              0231 DEFINED AT LINE 457
LOAD4:              023A DEFINED AT LINE 462
                    > USED AT LINE 446
                    > USED AT LINE 467
CSUMER:             024A DEFINED AT LINE 471
                    > USED AT LINE 459
DELV:               0250 DEFINED AT LINE 483
                    > USED AT LINE 652
DEL2:               0253 DEFINED AT LINE 486
                    > USED AT LINE 493
DEL1:               0256 DEFINED AT LINE 488
                    > USED AT LINE 491
WARMB:              0261 DEFINED AT LINE 507
                    > USED AT LINE 263
                    > USED AT LINE 267
                    > USED AT LINE 574
                    > USED AT LINE 576
CTLPRT:             0002 DEFINED AT LINE 524
                    > USED AT LINE 538
                    > USED AT LINE 557
                    > USED AT LINE 569
                    > USED AT LINE 601
                    > USED AT LINE 630
                    > USED AT LINE 650
                    > USED AT LINE 654
DATPRT:             0001 DEFINED AT LINE 525
                    > USED AT LINE 560
                    > USED AT LINE 572
                    > USED AT LINE 592
                    > USED AT LINE 605
                    > USED AT LINE 617
                    > USED AT LINE 634
SETUP:              026A DEFINED AT LINE 534
                    > USED AT LINE 24
INURT:              0272 DEFINED AT LINE 537
                    > USED AT LINE 541
CINNE:              0285 DEFINED AT LINE 557
                    > USED AT LINE 305
                    > USED AT LINE 312
                    > USED AT LINE 424
                    > USED AT LINE 464
                    > USED AT LINE 559
                    > USED AT LINE 616
CINHX:              028E DEFINED AT LINE 569
                    > USED AT LINE 279
                    > USED AT LINE 288
                    > USED AT LINE 571
                    > USED AT LINE 580
                    > USED AT LINE 584
                    > USED AT LINE 588
                    > USED AT LINE 590
GOOD:               02BB DEFINED AT LINE 592
                    > USED AT LINE 582
                    > USED AT LINE 586
CINW:               02BE DEFINED AT LINE 601
                    > USED AT LINE 161
CIN:                02C8 DEFINED AT LINE 616
                    > USED AT LINE 61
COUT:               02CE DEFINED AT LINE 628
                    > USED AT LINE 131
                    > USED AT LINE 190
                    > USED AT LINE 223
                    > USED AT LINE 227
                    > USED AT LINE 364
                    > USED AT LINE 377
COUT1:              02D0 DEFINED AT LINE 630
                    > USED AT LINE 632
BEEP:               02DB DEFINED AT LINE 648
                    > USED AT LINE 542
INIUART:            02ED DEFINED AT LINE 658
                    > USED AT LINE 535
UARTC:              02F2 DEFINED AT LINE 659
                    > USED AT LINE 648
                    > USED AT LINE 653
MSG:                02F3 DEFINED AT LINE 662
                    > USED AT LINE 53
HELPT:              0316 DEFINED AT LINE 667
                    > USED AT LINE 96
PROMPT:             047C DEFINED AT LINE 680
                    > USED AT LINE 57
CSERR:              0481 DEFINED AT LINE 681
                    > USED AT LINE 471
ERR:                048A DEFINED AT LINE 682
                    > USED AT LINE 81
CRLFT:              0490 DEFINED AT LINE 683
                    > USED AT LINE 402
HEX8L:              0493 DEFINED AT LINE 684
HEX8C:              04A3 DEFINED AT LINE 685
                    > USED AT LINE 468
LOGMSG:             04BB DEFINED AT LINE 689
                    > USED AT LINE 47
FLINE:              0570 DEFINED AT LINE 700
                    > USED AT LINE 51
VERSION:            0589 DEFINED AT LINE 702
                    > USED AT LINE 49
